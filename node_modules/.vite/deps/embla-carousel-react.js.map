{
  "version": 3,
  "sources": ["../../embla-carousel-react/src/components/utils.ts", "../../embla-carousel-react/src/components/index.ts"],
  "sourcesContent": ["import EmblaCarousel, { EmblaPluginType } from 'embla-carousel'\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[],\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[],\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const { areEqual } = EmblaCarousel.optionsHandler()\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areEqual(optionA, optionB)\n  })\n}\n", "import { useRef, useEffect, useState, useCallback } from 'react'\nimport { arePluginsEqual, canUseDOM } from './utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = [],\n): UseEmblaCarouselType {\n  const optionsHandler = useRef(EmblaCarousel.optionsHandler())\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current)\n  }, [embla])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmbla = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current,\n      )\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, setEmbla])\n\n  useEffect(() => {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return\n\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, embla]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n"],
  "mappings": ";;;;;;;;;;;;SAEgBA,YAAS;AACvB,SAAO,CAAC,EACN,OAAOC,WAAW,eAClBA,OAAOC,YACPD,OAAOC,SAASC;AAEnB;AAEK,SAAUC,0BACdC,SAA0B;AAE1B,SAAOA,QACJC,OADI,EAEJC,KAAK,SAACC,GAAGC,GAAM;AAAA,WAACD,EAAEE,OAAOD,EAAEC,OAAO,IAAI;EAAG,CAFrC,EAGJC,IAAI,SAACC,QAAW;AAAA,WAAAA,OAAOC;EAAO,CAH1B;AAIR;AAEe,SAAAC,gBACdC,UACAC,UAA2B;AAE3B,MAAID,SAASE,WAAWD,SAASC;AAAQ,WAAO;AAExC,MAAAC,WAAaC,cAAcC,eAAd,EAAA;AACrB,MAAMC,WAAWjB,0BAA0BW,QAAD;AAC1C,MAAMO,WAAWlB,0BAA0BY,QAAD;AAE1C,SAAOK,SAASE,MAAM,SAACC,SAASC,OAAK;AACnC,QAAMC,UAAUJ,SAASG,KAAD;AACxB,WAAOP,SAASM,SAASE,OAAV;EAChB,CAHM;AAIR;AChBD,SAASC,iBACPd,SACAR,SAA+B;AAD/B,MAAAQ,YAAA,QAAA;AAAAA,cAA8B,CAAA;EAAA;AAC9B,MAAAR,YAAA,QAAA;AAAAA,cAA+B,CAAA;EAAA;AAE/B,MAAMe,qBAAiBQ,qBAAOT,cAAcC,eAAd,CAAD;AAC7B,MAAMS,oBAAgBD,qBAAOf,OAAD;AAC5B,MAAMiB,oBAAgBF,qBAAOvB,OAAD;AACtB,MAAA0B,SAAoBC,uBAAQ,GAA3BC,QAAKF,GAAA,CAAA,GAAEG,WAAQH,GAAA,CAAA;AAChB,MAAAI,SAA0BH,uBAAQ,GAAjCI,WAAQD,GAAA,CAAA,GAAEE,cAAWF,GAAA,CAAA;AAE5B,MAAMG,aAASC,0BAAY,WAAA;AACzB,QAAIN;AAAOA,YAAMK,OAAOT,cAAcW,SAASV,cAAcU,OAAlD;EACZ,GAAE,CAACP,KAAD,CAFuB;AAI1BQ,8BAAU,WAAA;AACR,QAAIzC,UAAS,KAAMoC,UAAU;AAC3BjB,oBAAcuB,gBAAgBf,iBAAiBe;AAC/C,UAAMC,aAAWxB,cACfiB,UACAP,cAAcW,SACdV,cAAcU,OAHc;AAK9BN,eAASS,UAAD;AACR,aAAO,WAAA;AAAM,eAAAA,WAASC,QAAT;;IACd,OAAM;AACLV,eAASW,MAAD;IACT;EACF,GAAE,CAACT,UAAUF,QAAX,CAbM;AAeTO,8BAAU,WAAA;AACR,QAAIrB,eAAeoB,QAAQtB,SAASW,cAAcW,SAAS3B,OAAvD;AAAiE;AAErEgB,kBAAcW,UAAU3B;AACxByB,WAAM;EACP,GAAE,CAACzB,SAASyB,MAAV,CALM;AAOTG,8BAAU,WAAA;AACR,QAAI3B,gBAAgBgB,cAAcU,SAASnC,OAAxB;AAAkC;AAErDyB,kBAAcU,UAAUnC;AACxBiC,WAAM;EACP,GAAE,CAACjC,SAASiC,MAAV,CALM;AAOT,SAAO,CAAuBD,aAAaJ,KAApC;AACR;AAEDN,iBAAiBe,gBAA8CG;",
  "names": ["canUseDOM", "window", "document", "createElement", "sortAndMapPluginToOptions", "plugins", "concat", "sort", "a", "b", "name", "map", "plugin", "options", "arePluginsEqual", "pluginsA", "pluginsB", "length", "areEqual", "EmblaCarousel", "optionsHandler", "optionsA", "optionsB", "every", "optionA", "index", "optionB", "useEmblaCarousel", "useRef", "storedOptions", "storedPlugins", "_a", "useState", "embla", "setEmbla", "_b", "viewport", "setViewport", "reInit", "useCallback", "current", "useEffect", "globalOptions", "newEmbla_1", "destroy", "undefined"]
}
