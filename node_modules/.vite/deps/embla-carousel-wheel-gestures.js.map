{
  "version": 3,
  "sources": ["../../wheel-gestures/src/utils/projection.ts", "../../wheel-gestures/src/utils/index.ts", "../../wheel-gestures/src/events/EventBus.ts", "../../wheel-gestures/src/events/WheelTargetObserver.ts", "../../wheel-gestures/src/wheel-normalizer/wheel-normalizer.ts", "../../wheel-gestures/src/wheel-gestures/constants.ts", "../../wheel-gestures/src/wheel-gestures/options.ts", "../../wheel-gestures/src/wheel-gestures/state.ts", "../../wheel-gestures/src/wheel-gestures/wheel-gestures.ts", "../../embla-carousel-wheel-gestures/src/WheelGesturesPlugin.ts"],
  "sourcesContent": ["const DECAY = 0.996\n\n/**\n * movement projection based on velocity\n * @param velocityPxMs\n * @param decay\n */\nexport const projection = (velocityPxMs: number, decay = DECAY) => (velocityPxMs * decay) / (1 - decay)\n", "export * from './projection'\n\nexport function lastOf<T>(array: T[]) {\n  return array[array.length - 1]\n}\n\nexport function average(numbers: number[]) {\n  return numbers.reduce((a, b) => a + b) / numbers.length\n}\n\nexport const clamp = (value: number, min: number, max: number) => Math.min(Math.max(min, value), max)\n\nexport function addVectors<T extends number[]>(v1: T, v2: T): T {\n  if (v1.length !== v2.length) {\n    throw new Error('vectors must be same length')\n  }\n  return v1.map((val, i) => val + v2[i]) as T\n}\n\nexport function absMax(numbers: number[]) {\n  return Math.max(...numbers.map(Math.abs))\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function deepFreeze<T extends object>(o: T): Readonly<T> {\n  Object.freeze(o)\n  Object.values(o).forEach((value) => {\n    if (value !== null && typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value)\n    }\n  })\n  return o\n}\n", "import { deepFreeze } from '../utils'\n\nexport type EventMapEmpty = Record<string, unknown>\nexport type EventListener<D = unknown> = (data: D) => void\nexport type Off = () => void\n\nexport default function EventBus<EventMap = EventMapEmpty>() {\n  const listeners = {} as Record<keyof EventMap, EventListener<never>[]>\n\n  function on<EK extends keyof EventMap>(type: EK, listener: EventListener<EventMap[EK]>): Off {\n    listeners[type] = (listeners[type] || []).concat(listener)\n    return () => off(type, listener)\n  }\n\n  function off<EK extends keyof EventMap>(type: EK, listener: EventListener<EventMap[EK]>) {\n    listeners[type] = (listeners[type] || []).filter((l) => l !== listener)\n  }\n\n  function dispatch<EK extends keyof EventMap>(type: EK, data: EventMap[EK]) {\n    if (!(type in listeners)) return\n    ;(listeners[type] as EventListener<EventMap[EK]>[]).forEach((l) => l(data))\n  }\n\n  return deepFreeze({\n    on,\n    off,\n    dispatch,\n  })\n}\n", "import { WheelEventData } from '../types'\nimport { deepFreeze } from '../utils'\n\ntype UnobserveTarget = () => void\n\nexport function WheelTargetObserver(eventListener: (wheelEvent: WheelEventData) => void) {\n  let targets: EventTarget[] = []\n\n  // add event listener to target element\n  const observe = (target: EventTarget): UnobserveTarget => {\n    target.addEventListener('wheel', eventListener as EventListener, { passive: false })\n    targets.push(target)\n\n    return () => unobserve(target)\n  }\n\n  /// remove event listener from target element\n  const unobserve = (target: EventTarget) => {\n    target.removeEventListener('wheel', eventListener as EventListener)\n    targets = targets.filter((t) => t !== target)\n  }\n\n  // stops watching all of its target elements for visibility changes.\n  const disconnect = () => {\n    targets.forEach(unobserve)\n  }\n\n  return deepFreeze({\n    observe,\n    unobserve,\n    disconnect,\n  })\n}\n", "import { ReverseSign, VectorXYZ, WheelEventData } from '../types'\nimport { clamp } from '../utils'\n\nexport interface NormalizedWheel {\n  axisDelta: VectorXYZ\n  timeStamp: number\n}\n\nconst LINE_HEIGHT = 16 * 1.125\nconst PAGE_HEIGHT = (typeof window !== 'undefined' && window.innerHeight) || 800\nconst DELTA_MODE_UNIT = [1, LINE_HEIGHT, PAGE_HEIGHT]\n\nexport function normalizeWheel(e: WheelEventData): NormalizedWheel {\n  const deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode]\n  const deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode]\n  const deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode]\n\n  return {\n    timeStamp: e.timeStamp,\n    axisDelta: [deltaX, deltaY, deltaZ],\n  }\n}\n\nconst reverseAll = [-1, -1, -1]\n\nexport function reverseAxisDeltaSign<T extends Pick<NormalizedWheel, 'axisDelta'>>(\n  wheel: T,\n  reverseSign: ReverseSign\n): T {\n  if (!reverseSign) {\n    return wheel\n  }\n\n  const multipliers = reverseSign === true ? reverseAll : reverseSign.map((shouldReverse) => (shouldReverse ? -1 : 1))\n\n  return {\n    ...wheel,\n    axisDelta: wheel.axisDelta.map((delta, i) => delta * multipliers[i]),\n  }\n}\n\nconst DELTA_MAX_ABS = 700\n\nexport const clampAxisDelta = <T extends Pick<NormalizedWheel, 'axisDelta'>>(wheel: T) => {\n  return {\n    ...wheel,\n    axisDelta: wheel.axisDelta.map((delta) => clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS)),\n  }\n}\n", "export const __DEV__ = process.env.NODE_ENV !== 'production'\nexport const ACC_FACTOR_MIN = 0.6\nexport const ACC_FACTOR_MAX = 0.96\nexport const WHEELEVENTS_TO_MERGE = 2\nexport const WHEELEVENTS_TO_ANALAZE = 5\n", "import { WheelGesturesConfig } from '../types'\nimport { deepFreeze } from '../utils'\n\nexport const configDefaults: WheelGesturesConfig = deepFreeze({\n  preventWheelAction: true,\n  reverseSign: [true, true, false],\n})\n", "/**\n * the timeout is automatically adjusted during a gesture\n * the initial timeout period is pretty long, so even old mouses, which emit wheel events less often, can produce a continuous gesture\n */\nimport { WheelGesturesInternalState } from './internal-types'\n\nconst WILL_END_TIMEOUT_DEFAULT = 400\n\nexport function createWheelGesturesState(): WheelGesturesInternalState {\n  return {\n    isStarted: false,\n    isStartPublished: false,\n    isMomentum: false,\n    startTime: 0,\n    lastAbsDelta: Infinity,\n    axisMovement: [0, 0, 0],\n    axisVelocity: [0, 0, 0],\n    accelerationFactors: [],\n    scrollPoints: [],\n    scrollPointsToMerge: [],\n    willEndTimeout: WILL_END_TIMEOUT_DEFAULT,\n  }\n}\n", "import EventBus from '../events/EventBus'\nimport { WheelTargetObserver } from '../events/WheelTargetObserver'\nimport {\n  VectorXYZ,\n  WheelEventData,\n  WheelEventState,\n  WheelGesturesConfig,\n  WheelGesturesEventMap,\n  WheelGesturesOptions,\n} from '../types'\nimport { absMax, addVectors, average, deepFreeze, lastOf, projection } from '../utils'\nimport { clampAxisDelta, normalizeWheel, reverseAxisDeltaSign } from '../wheel-normalizer/wheel-normalizer'\nimport { __DEV__, ACC_FACTOR_MAX, ACC_FACTOR_MIN, WHEELEVENTS_TO_ANALAZE, WHEELEVENTS_TO_MERGE } from './constants'\nimport { configDefaults } from './options'\nimport { createWheelGesturesState } from './state'\n\nexport function WheelGestures(optionsParam: WheelGesturesOptions = {}) {\n  const { on, off, dispatch } = EventBus<WheelGesturesEventMap>()\n  let config = configDefaults\n  let state = createWheelGesturesState()\n  let currentEvent: WheelEventData\n  let negativeZeroFingerUpSpecialEvent = false\n  let prevWheelEventState: WheelEventState | undefined\n\n  const feedWheel = (wheelEvents: WheelEventData | WheelEventData[]) => {\n    if (Array.isArray(wheelEvents)) {\n      wheelEvents.forEach((wheelEvent) => processWheelEventData(wheelEvent))\n    } else {\n      processWheelEventData(wheelEvents)\n    }\n  }\n\n  const updateOptions = (newOptions: WheelGesturesOptions = {}): WheelGesturesConfig => {\n    if (Object.values(newOptions).some((option) => option === undefined || option === null)) {\n      __DEV__ && console.error('updateOptions ignored! undefined & null options not allowed')\n      return config\n    }\n    return (config = deepFreeze({ ...configDefaults, ...config, ...newOptions }))\n  }\n\n  const publishWheel = (additionalData?: Partial<WheelEventState>) => {\n    const wheelEventState: WheelEventState = {\n      event: currentEvent,\n      isStart: false,\n      isEnding: false,\n      isMomentumCancel: false,\n      isMomentum: state.isMomentum,\n      axisDelta: [0, 0, 0],\n      axisVelocity: state.axisVelocity,\n      axisMovement: state.axisMovement,\n      get axisMovementProjection() {\n        return addVectors(\n          wheelEventState.axisMovement,\n          wheelEventState.axisVelocity.map((velocity) => projection(velocity)) as VectorXYZ\n        )\n      },\n      ...additionalData,\n    }\n\n    dispatch('wheel', {\n      ...wheelEventState,\n      previous: prevWheelEventState,\n    })\n\n    // keep reference without previous, otherwise we would create a long chain\n    prevWheelEventState = wheelEventState\n  }\n\n  // should prevent when there is mainly movement on the desired axis\n  const shouldPreventDefault = (deltaMaxAbs: number, axisDelta: VectorXYZ): boolean => {\n    const { preventWheelAction } = config\n    const [deltaX, deltaY, deltaZ] = axisDelta\n\n    if (typeof preventWheelAction === 'boolean') return preventWheelAction\n\n    switch (preventWheelAction) {\n      case 'x':\n        return Math.abs(deltaX) >= deltaMaxAbs\n      case 'y':\n        return Math.abs(deltaY) >= deltaMaxAbs\n      case 'z':\n        return Math.abs(deltaZ) >= deltaMaxAbs\n      default:\n        __DEV__ && console.warn('unsupported preventWheelAction value: ' + preventWheelAction, 'warn')\n        return false\n    }\n  }\n\n  const processWheelEventData = (wheelEvent: WheelEventData) => {\n    const { axisDelta, timeStamp } = clampAxisDelta(\n      reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)\n    )\n    const deltaMaxAbs = absMax(axisDelta)\n\n    if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) {\n      wheelEvent.preventDefault()\n    }\n\n    if (!state.isStarted) {\n      start()\n    }\n    // check if user started scrolling again -> cancel\n    else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {\n      end(true)\n      start()\n    }\n\n    // special finger up event on windows + blink\n    if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {\n      negativeZeroFingerUpSpecialEvent = true\n      // return -> zero delta event should not influence velocity\n      return\n    }\n\n    currentEvent = wheelEvent\n    state.axisMovement = addVectors(state.axisMovement, axisDelta)\n    state.lastAbsDelta = deltaMaxAbs\n    state.scrollPointsToMerge.push({\n      axisDelta,\n      timeStamp,\n    })\n\n    mergeScrollPointsCalcVelocity()\n\n    // only wheel event (move) and not start/end get the delta values\n    publishWheel({ axisDelta, isStart: !state.isStartPublished }) // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })\n\n    // publish start after velocity etc. have been updated\n    state.isStartPublished = true\n\n    // calc debounced end function, to recognize end of wheel event stream\n    willEnd()\n  }\n\n  const mergeScrollPointsCalcVelocity = () => {\n    if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {\n      state.scrollPoints.unshift({\n        axisDeltaSum: state.scrollPointsToMerge.map((b) => b.axisDelta).reduce(addVectors),\n        timeStamp: average(state.scrollPointsToMerge.map((b) => b.timeStamp)),\n      })\n\n      // only update velocity after a merged scrollpoint was generated\n      updateVelocity()\n\n      // reset toMerge array\n      state.scrollPointsToMerge.length = 0\n\n      // after calculation of velocity only keep the most recent merged scrollPoint\n      state.scrollPoints.length = 1\n\n      if (!state.isMomentum) {\n        detectMomentum()\n      }\n    } else if (!state.isStartPublished) {\n      updateStartVelocity()\n    }\n  }\n\n  const updateStartVelocity = () => {\n    state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map((d) => d / state.willEndTimeout) as VectorXYZ\n  }\n\n  const updateVelocity = () => {\n    // need to have two recent points to calc velocity\n    const [latestScrollPoint, prevScrollPoint] = state.scrollPoints\n\n    if (!prevScrollPoint || !latestScrollPoint) {\n      return\n    }\n\n    // time delta\n    const deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp\n\n    if (deltaTime <= 0) {\n      __DEV__ && console.warn('invalid deltaTime')\n      return\n    }\n\n    // calc the velocity per axes\n    const velocity = latestScrollPoint.axisDeltaSum.map((d) => d / deltaTime) as VectorXYZ\n\n    // calc the acceleration factor per axis\n    const accelerationFactor = velocity.map((v, i) => v / (state.axisVelocity[i] || 1))\n\n    state.axisVelocity = velocity\n    state.accelerationFactors.push(accelerationFactor)\n\n    updateWillEndTimeout(deltaTime)\n  }\n\n  const updateWillEndTimeout = (deltaTime: number) => {\n    // use current time between events rounded up and increased by a bit as timeout\n    let newTimeout = Math.ceil(deltaTime / 10) * 10 * 1.2\n\n    // double the timeout, when momentum was not detected yet\n    if (!state.isMomentum) {\n      newTimeout = Math.max(100, newTimeout * 2)\n    }\n\n    state.willEndTimeout = Math.min(1000, Math.round(newTimeout))\n  }\n\n  const accelerationFactorInMomentumRange = (accFactor: number) => {\n    // when main axis is the the other one and there is no movement/change on the current one\n    if (accFactor === 0) return true\n    return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN\n  }\n\n  const detectMomentum = () => {\n    if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {\n      if (negativeZeroFingerUpSpecialEvent) {\n        negativeZeroFingerUpSpecialEvent = false\n\n        if (absMax(state.axisVelocity) >= 0.2) {\n          recognizedMomentum()\n          return\n        }\n      }\n\n      const recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1)\n\n      // check recent acceleration / deceleration factors\n      // all recent need to match, if any did not match\n      const detectedMomentum = recentAccelerationFactors.every((accFac) => {\n        // when both axis decelerate exactly in the same rate it is very likely caused by momentum\n        const sameAccFac = !!accFac.reduce((f1, f2) => (f1 && f1 < 1 && f1 === f2 ? 1 : 0))\n\n        // check if acceleration factor is within momentum range\n        const bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length\n\n        // one the requirements must be fulfilled\n        return sameAccFac || bothAreInRangeOrZero\n      })\n\n      if (detectedMomentum) {\n        recognizedMomentum()\n      }\n\n      // only keep the most recent events\n      state.accelerationFactors = recentAccelerationFactors\n    }\n  }\n\n  const recognizedMomentum = () => {\n    state.isMomentum = true\n  }\n\n  const start = () => {\n    state = createWheelGesturesState()\n    state.isStarted = true\n    state.startTime = Date.now()\n    prevWheelEventState = undefined\n    negativeZeroFingerUpSpecialEvent = false\n  }\n\n  const willEnd = (() => {\n    let willEndId: number\n    return () => {\n      clearTimeout(willEndId)\n      willEndId = setTimeout(end, state.willEndTimeout)\n    }\n  })()\n\n  const end = (isMomentumCancel = false) => {\n    if (!state.isStarted) return\n\n    if (state.isMomentum && isMomentumCancel) {\n      publishWheel({ isEnding: true, isMomentumCancel: true })\n    } else {\n      publishWheel({ isEnding: true })\n    }\n\n    state.isMomentum = false\n    state.isStarted = false\n  }\n\n  const { observe, unobserve, disconnect } = WheelTargetObserver(feedWheel)\n\n  updateOptions(optionsParam)\n\n  return deepFreeze({\n    on,\n    off,\n    observe,\n    unobserve,\n    disconnect,\n    feedWheel,\n    updateOptions,\n  })\n}\n", "import EmblaCarousel, { EmblaCarouselType } from 'embla-carousel'\nimport { CreateOptionsType } from 'embla-carousel/components/Options'\nimport { CreatePluginType } from 'embla-carousel/components/Plugins'\nimport WheelGestures, { WheelEventState } from 'wheel-gestures'\n\nexport type WheelGesturesPluginOptions = CreateOptionsType<{\n  wheelDraggingClass: string\n  forceWheelAxis?: 'x' | 'y'\n  target?: Element\n}>\n\ntype WheelGesturesPluginUserOptions = Partial<WheelGesturesPluginOptions>\ntype WheelGesturesPluginType = CreatePluginType<{}, WheelGesturesPluginOptions>\n\nconst defaultOptions: WheelGesturesPluginOptions = {\n  active: true,\n  breakpoints: {},\n  wheelDraggingClass: 'is-wheel-dragging',\n  forceWheelAxis: undefined,\n  target: undefined,\n}\n\nWheelGesturesPlugin.globalOptions = undefined as WheelGesturesPluginUserOptions | undefined\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\n\nexport function WheelGesturesPlugin(userOptions?: WheelGesturesPluginUserOptions): WheelGesturesPluginType {\n  const optionsHandler = EmblaCarousel.optionsHandler()\n  const optionsBase = optionsHandler.merge(defaultOptions, WheelGesturesPlugin.globalOptions)\n  let options: WheelGesturesPluginType['options']\n\n  let cleanup = () => {}\n\n  function init(embla: EmblaCarouselType) {\n    options = optionsHandler.atMedia(self.options)\n    const engine = embla.internalEngine()\n    const targetNode = options.target ?? (embla.containerNode().parentNode as Element)\n    const wheelAxis = options.forceWheelAxis ?? engine.options.axis\n    const wheelGestures = WheelGestures({\n      preventWheelAction: wheelAxis,\n      reverseSign: [true, true, false],\n    })\n\n    const unobserveTargetNode = wheelGestures.observe(targetNode)\n    const offWheel = wheelGestures.on('wheel', handleWheel)\n\n    let isStarted = false\n    let startEvent: MouseEvent\n\n    function wheelGestureStarted(state: WheelEventState) {\n      try {\n        startEvent = new MouseEvent('mousedown', state.event)\n        dispatchEvent(startEvent)\n      } catch (e) {\n        // Legacy Browsers like IE 10 & 11 will throw when attempting to create the Event\n        if (__DEV__) {\n          console.warn(\n            'Legacy browser requires events-polyfill (https://github.com/xiel/embla-carousel-wheel-gestures#legacy-browsers)'\n          )\n        }\n        return cleanup()\n      }\n\n      isStarted = true\n      addNativeMouseEventListeners()\n\n      if (options.wheelDraggingClass) {\n        targetNode.classList.add(options.wheelDraggingClass)\n      }\n    }\n\n    function wheelGestureEnded(state: WheelEventState) {\n      isStarted = false\n      dispatchEvent(createRelativeMouseEvent('mouseup', state))\n      removeNativeMouseEventListeners()\n\n      if (options.wheelDraggingClass) {\n        targetNode.classList.remove(options.wheelDraggingClass)\n      }\n    }\n\n    function addNativeMouseEventListeners() {\n      document.documentElement.addEventListener('mousemove', preventNativeMouseHandler, true)\n      document.documentElement.addEventListener('mouseup', preventNativeMouseHandler, true)\n      document.documentElement.addEventListener('mousedown', preventNativeMouseHandler, true)\n    }\n\n    function removeNativeMouseEventListeners() {\n      document.documentElement.removeEventListener('mousemove', preventNativeMouseHandler, true)\n      document.documentElement.removeEventListener('mouseup', preventNativeMouseHandler, true)\n      document.documentElement.removeEventListener('mousedown', preventNativeMouseHandler, true)\n    }\n\n    function preventNativeMouseHandler(e: MouseEvent) {\n      if (isStarted && e.isTrusted) {\n        e.stopImmediatePropagation()\n      }\n    }\n\n    function createRelativeMouseEvent(type: 'mousedown' | 'mousemove' | 'mouseup', state: WheelEventState) {\n      let moveX, moveY\n\n      if (wheelAxis === engine.options.axis) {\n        ;[moveX, moveY] = state.axisMovement\n      } else {\n        // if emblas axis and the wheelAxis don't match, swap the axes to match the right embla events\n        ;[moveY, moveX] = state.axisMovement\n      }\n\n      return new MouseEvent(type, {\n        clientX: startEvent.clientX + moveX,\n        clientY: startEvent.clientY + moveY,\n        screenX: startEvent.screenX + moveX,\n        screenY: startEvent.screenY + moveY,\n        movementX: moveX,\n        movementY: moveY,\n        button: 0,\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n      })\n    }\n\n    function dispatchEvent(event: UIEvent) {\n      embla.containerNode().dispatchEvent(event)\n    }\n\n    function handleWheel(state: WheelEventState) {\n      const {\n        axisDelta: [deltaX, deltaY],\n      } = state\n      const primaryAxisDelta = wheelAxis === 'x' ? deltaX : deltaY\n      const crossAxisDelta = wheelAxis === 'x' ? deltaY : deltaX\n      const isRelease = state.isMomentum && state.previous && !state.previous.isMomentum\n      const isEndingOrRelease = (state.isEnding && !state.isMomentum) || isRelease\n      const primaryAxisDeltaIsDominant = Math.abs(primaryAxisDelta) > Math.abs(crossAxisDelta)\n\n      if (primaryAxisDeltaIsDominant && !isStarted && !state.isMomentum) {\n        wheelGestureStarted(state)\n      }\n\n      if (!isStarted) return\n      if (isEndingOrRelease) {\n        wheelGestureEnded(state)\n      } else {\n        dispatchEvent(createRelativeMouseEvent('mousemove', state))\n      }\n    }\n\n    cleanup = () => {\n      unobserveTargetNode()\n      offWheel()\n      removeNativeMouseEventListeners()\n    }\n  }\n\n  const self: WheelGesturesPluginType = {\n    name: 'wheelGestures',\n    options: optionsHandler.merge(optionsBase, userOptions),\n    init,\n    destroy: () => cleanup(),\n  }\n  return self\n}\n"],
  "mappings": "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",
  "names": ["DECAY", "projection", "velocityPxMs", "decay", "lastOf", "array", "length", "average", "numbers", "reduce", "a", "b", "clamp", "value", "min", "max", "Math", "addVectors", "v1", "v2", "Error", "map", "val", "i", "absMax", "abs", "deepFreeze", "o", "Object", "freeze", "values", "forEach", "isFrozen", "EventBus", "listeners", "on", "type", "listener", "concat", "off", "filter", "l", "dispatch", "data", "WheelTargetObserver", "eventListener", "targets", "observe", "target", "addEventListener", "passive", "push", "unobserve", "removeEventListener", "t", "disconnect", "LINE_HEIGHT", "PAGE_HEIGHT", "window", "innerHeight", "DELTA_MODE_UNIT", "normalizeWheel", "e", "deltaX", "deltaMode", "deltaY", "deltaZ", "timeStamp", "axisDelta", "reverseAll", "reverseAxisDeltaSign", "wheel", "reverseSign", "multipliers", "shouldReverse", "delta", "DELTA_MAX_ABS", "clampAxisDelta", "__DEV__", "process", "ACC_FACTOR_MIN", "ACC_FACTOR_MAX", "WHEELEVENTS_TO_MERGE", "WHEELEVENTS_TO_ANALAZE", "configDefaults", "preventWheelAction", "WILL_END_TIMEOUT_DEFAULT", "createWheelGesturesState", "isStarted", "isStartPublished", "isMomentum", "startTime", "lastAbsDelta", "Infinity", "axisMovement", "axisVelocity", "accelerationFactors", "scrollPoints", "scrollPointsToMerge", "willEndTimeout", "WheelGestures", "optionsParam", "config", "state", "currentEvent", "negativeZeroFingerUpSpecialEvent", "prevWheelEventState", "feedWheel", "wheelEvents", "Array", "isArray", "wheelEvent", "processWheelEventData", "updateOptions", "newOptions", "some", "option", "undefined", "console", "error", "publishWheel", "additionalData", "wheelEventState", "event", "isStart", "isEnding", "isMomentumCancel", "axisMovementProjection", "velocity", "previous", "shouldPreventDefault", "deltaMaxAbs", "warn", "preventDefault", "start", "end", "is", "mergeScrollPointsCalcVelocity", "willEnd", "unshift", "axisDeltaSum", "updateVelocity", "detectMomentum", "updateStartVelocity", "d", "latestScrollPoint", "prevScrollPoint", "deltaTime", "accelerationFactor", "v", "updateWillEndTimeout", "newTimeout", "ceil", "round", "accelerationFactorInMomentumRange", "accFactor", "recognizedMomentum", "recentAccelerationFactors", "slice", "detectedMomentum", "every", "accFac", "sameAccFac", "f1", "f2", "bothAreInRangeOrZero", "Date", "now", "willEndId", "clearTimeout", "setTimeout", "defaultOptions", "active", "breakpoints", "wheelDraggingClass", "forceWheelAxis", "undefined", "target", "WheelGesturesPlugin", "globalOptions", "__DEV__", "process", "userOptions", "optionsHandler", "EmblaCarousel", "optionsBase", "merge", "options", "cleanup", "init", "embla", "atMedia", "self", "engine", "internalEngine", "targetNode", "containerNode", "parentNode", "wheelAxis", "axis", "wheelGestures", "WheelGestures", "preventWheelAction", "reverseSign", "unobserveTargetNode", "observe", "offWheel", "on", "handleWheel", "isStarted", "startEvent", "wheelGestureStarted", "state", "MouseEvent", "event", "dispatchEvent", "e", "console", "warn", "addNativeMouseEventListeners", "classList", "add", "wheelGestureEnded", "createRelativeMouseEvent", "removeNativeMouseEventListeners", "remove", "document", "documentElement", "addEventListener", "preventNativeMouseHandler", "removeEventListener", "isTrusted", "stopImmediatePropagation", "type", "moveX", "moveY", "axisMovement", "clientX", "clientY", "screenX", "screenY", "movementX", "movementY", "button", "bubbles", "cancelable", "composed", "axisDelta", "deltaX", "deltaY", "primaryAxisDelta", "crossAxisDelta", "isRelease", "isMomentum", "previous", "isEndingOrRelease", "isEnding", "primaryAxisDeltaIsDominant", "Math", "abs", "name", "destroy"]
}
